import ipaddress
from threading import Thread

from .scanner_service import scan_host, scan_hosts

from ..utils import log, get_timestamp
from ..repositories.network_repository import create_network, get_network_by_id, get_all_networks
from ..repositories.host_repository import create_host
from ..services.scanner_service import check_host_available, retrieve_hosts
from ..repositories.port__repository import create_port
from ..models.network import Network


def get_network_data(ip_and_subnet):
    # THIS FUNCTION WAS GENERATED BY CHATGPT
    # Parse the network
    network = ipaddress.ip_network(ip_and_subnet, strict=False)

    # Subnet address
    netmask = str(network.netmask)

    # All usable IP addresses in the network (excluding network and broadcast addresses)
    usable_ips = [str(ip) for ip in network.hosts()]

    # If you want *all* IPs (including network and broadcast), use:
    all_ips = [str(ip) for ip in network]
    return usable_ips, netmask



def add_network(ip_with_cidr:str):
    ''' Adds a network, will be called from the index when adding a network
    '''
    # Try-Except incase invalid data
    try:
        possible_hosts, subnet_mask = get_network_data(ip_with_cidr)
    except:
        return 'some error has prevented calculating the hosts / subnet'
    
    display_ip:str = ip_with_cidr.split('/')[0]
    network_id:int = create_network(ip_address=display_ip, subnet_mask=subnet_mask).id
    log(f'Added Network: {display_ip}')
    threads:list[Thread] = []
    found_hosts:list[str] = []
    for possible_host in possible_hosts:
        resp:bool = False
        thread = Thread(target=check_host_available, args=(possible_host,found_hosts,))
        threads.append(thread)
        thread.start()
    print(len(found_hosts))
    for thread in threads:
        thread.join()
    
    
    
    for host in found_hosts:
        log(f'Added host: {host} to network: {display_ip}', '+')
        create_host(ip_address=host, network_id=network_id)
    return 'network has been created'

def scan_network(id, option):
    ''' The active function called when wanting to scan a network
    Expects the values are already santized
    '''
    network_to_scan:Network = get_network_by_id(id)
    results = []
    for host in network_to_scan.hosts:
        results.append(scan_host(host, option))
    results_as_dicts = []
    with open('data.txt', 'w') as data:
        data.write(str(results))
    if option == 'ping':
        return f'{len(results)} Hosts are online'
        
    for host in results:
        for found_port in host:
            data = found_port

            create_port(port_number=data['port'],host_id=data['host'].id,service=data['service'],vulnerabilities=data['vulnerabilities'],
                        found_date=get_timestamp())
            long_vulnerability =len(data['vulnerabilities']) > 100
            results_as_dicts.append({'port_number':data['port'],
                                        'host_id':data['host'].id,
                                        'service':data['service'],
                                        'vulnerabilities':data['vulnerabilities'],
                                        'vuln_long':long_vulnerability,
                                        'found_date':get_timestamp()})
    return results_as_dicts
    # format it to give a simple overview
    if option == 'ping':
        return f'There are {len(results)} hosts online'
    else:
        hosts:list[int] = []
        ports:int = 0
        for result in results:
            create_port(port_number=result['port'], host_id=int(result['host'].id), 
                    service=result['service'], 
                    vulnerabilities=result['vulnerabilities'], 
                    found_date=result['last_found'])
            if result['host'].host_id not in hosts:
                hosts.append(result.host_id)
            ports += 1
            
        return f'found {ports} ports on {len(hosts)} hosts'

def get_all_networks_formatted():
    ''' Returns all Networks in the form of dicts, instead of hosts returns
    the length, in order to distinguish between a single host and networks of
    mutliple hosts
    '''
    networks:list[Network] = get_all_networks()
    # convert the network objects to dicts for ease of use in jinja2
    network_dicts:list[dict] = []
    for network in networks:
        network_dicts.append({'id': network.id, 'ip':network.ip, 
                      'subnet':network.subnet, 'size': len(network.hosts)})
    return network_dicts